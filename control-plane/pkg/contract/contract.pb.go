// Code generated by protoc-gen-go. DO NOT EDIT.
// source: contract.proto

package contract

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// BackoffPolicyType is the type for backoff policies
type BackoffPolicy int32

const (
	// Exponential backoff policy
	BackoffPolicy_Exponential BackoffPolicy = 0
	// Linear backoff policy
	BackoffPolicy_Linear BackoffPolicy = 1
)

var BackoffPolicy_name = map[int32]string{
	0: "Exponential",
	1: "Linear",
}

var BackoffPolicy_value = map[string]int32{
	"Exponential": 0,
	"Linear":      1,
}

func (x BackoffPolicy) String() string {
	return proto.EnumName(BackoffPolicy_name, int32(x))
}

func (BackoffPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{0}
}

// Check dev.knative.eventing.kafka.broker.dispatcher.consumer.DeliveryOrder for more details
type DeliveryOrder int32

const (
	DeliveryOrder_UNORDERED DeliveryOrder = 0
	DeliveryOrder_ORDERED   DeliveryOrder = 1
)

var DeliveryOrder_name = map[int32]string{
	0: "UNORDERED",
	1: "ORDERED",
}

var DeliveryOrder_value = map[string]int32{
	"UNORDERED": 0,
	"ORDERED":   1,
}

func (x DeliveryOrder) String() string {
	return proto.EnumName(DeliveryOrder_name, int32(x))
}

func (DeliveryOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{1}
}

// CloudEvent content mode
type ContentMode int32

const (
	ContentMode_BINARY     ContentMode = 0
	ContentMode_STRUCTURED ContentMode = 1
)

var ContentMode_name = map[int32]string{
	0: "BINARY",
	1: "STRUCTURED",
}

var ContentMode_value = map[string]int32{
	"BINARY":     0,
	"STRUCTURED": 1,
}

func (x ContentMode) String() string {
	return proto.EnumName(ContentMode_name, int32(x))
}

func (ContentMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{2}
}

// Protobuf include nightmare? No thanks!
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{0}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Filter struct {
	// attributes filters events by exact match on event context attributes.
	// Each key in the map is compared with the equivalent key in the event
	// context. An event passes the filter if all values are equal to the
	// specified values.
	//
	// Nested context attributes are not supported as keys. Only string values are supported.
	Attributes           map[string]string `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{1}
}

func (m *Filter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Filter.Unmarshal(m, b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return xxx_messageInfo_Filter.Size(m)
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type EgressConfig struct {
	// Dead letter is where the event is sent when something goes wrong
	DeadLetter string `protobuf:"bytes,1,opt,name=deadLetter,proto3" json:"deadLetter,omitempty"`
	// retry is the minimum number of retries the sender should attempt when
	// sending an event before moving it to the dead letter sink.
	//
	// Setting retry to 0 means don't retry.
	Retry uint32 `protobuf:"varint,2,opt,name=retry,proto3" json:"retry,omitempty"`
	// backoffPolicy is the retry backoff policy (linear, exponential).
	BackoffPolicy BackoffPolicy `protobuf:"varint,3,opt,name=backoffPolicy,proto3,enum=BackoffPolicy" json:"backoffPolicy,omitempty"`
	// backoffDelay is the delay before retrying in milliseconds.
	BackoffDelay         uint64   `protobuf:"varint,4,opt,name=backoffDelay,proto3" json:"backoffDelay,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EgressConfig) Reset()         { *m = EgressConfig{} }
func (m *EgressConfig) String() string { return proto.CompactTextString(m) }
func (*EgressConfig) ProtoMessage()    {}
func (*EgressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{2}
}

func (m *EgressConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EgressConfig.Unmarshal(m, b)
}
func (m *EgressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EgressConfig.Marshal(b, m, deterministic)
}
func (m *EgressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressConfig.Merge(m, src)
}
func (m *EgressConfig) XXX_Size() int {
	return xxx_messageInfo_EgressConfig.Size(m)
}
func (m *EgressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_EgressConfig proto.InternalMessageInfo

func (m *EgressConfig) GetDeadLetter() string {
	if m != nil {
		return m.DeadLetter
	}
	return ""
}

func (m *EgressConfig) GetRetry() uint32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *EgressConfig) GetBackoffPolicy() BackoffPolicy {
	if m != nil {
		return m.BackoffPolicy
	}
	return BackoffPolicy_Exponential
}

func (m *EgressConfig) GetBackoffDelay() uint64 {
	if m != nil {
		return m.BackoffDelay
	}
	return 0
}

type Egress struct {
	// consumer group name
	ConsumerGroup string `protobuf:"bytes,1,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	// destination is the sink where events are sent.
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to ReplyStrategy:
	//	*Egress_ReplyUrl
	//	*Egress_ReplyToOriginalTopic
	ReplyStrategy isEgress_ReplyStrategy `protobuf_oneof:"replyStrategy"`
	Filter        *Filter                `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
	// Id of the egress
	// It's the same as the Kubernetes resource uid
	Uid string `protobuf:"bytes,6,opt,name=uid,proto3" json:"uid,omitempty"`
	// Egress configuration.
	// It overrides Resource's EgressConfig.
	EgressConfig *EgressConfig `protobuf:"bytes,7,opt,name=egressConfig,proto3" json:"egressConfig,omitempty"`
	// Delivery guarantee to use
	// Empty defaults to unordered
	DeliveryOrder        DeliveryOrder `protobuf:"varint,8,opt,name=deliveryOrder,proto3,enum=DeliveryOrder" json:"deliveryOrder,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Egress) Reset()         { *m = Egress{} }
func (m *Egress) String() string { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()    {}
func (*Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{3}
}

func (m *Egress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Egress.Unmarshal(m, b)
}
func (m *Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Egress.Marshal(b, m, deterministic)
}
func (m *Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Egress.Merge(m, src)
}
func (m *Egress) XXX_Size() int {
	return xxx_messageInfo_Egress.Size(m)
}
func (m *Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Egress proto.InternalMessageInfo

func (m *Egress) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *Egress) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type isEgress_ReplyStrategy interface {
	isEgress_ReplyStrategy()
}

type Egress_ReplyUrl struct {
	ReplyUrl string `protobuf:"bytes,3,opt,name=replyUrl,proto3,oneof"`
}

type Egress_ReplyToOriginalTopic struct {
	ReplyToOriginalTopic *Empty `protobuf:"bytes,4,opt,name=replyToOriginalTopic,proto3,oneof"`
}

func (*Egress_ReplyUrl) isEgress_ReplyStrategy() {}

func (*Egress_ReplyToOriginalTopic) isEgress_ReplyStrategy() {}

func (m *Egress) GetReplyStrategy() isEgress_ReplyStrategy {
	if m != nil {
		return m.ReplyStrategy
	}
	return nil
}

func (m *Egress) GetReplyUrl() string {
	if x, ok := m.GetReplyStrategy().(*Egress_ReplyUrl); ok {
		return x.ReplyUrl
	}
	return ""
}

func (m *Egress) GetReplyToOriginalTopic() *Empty {
	if x, ok := m.GetReplyStrategy().(*Egress_ReplyToOriginalTopic); ok {
		return x.ReplyToOriginalTopic
	}
	return nil
}

func (m *Egress) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Egress) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Egress) GetEgressConfig() *EgressConfig {
	if m != nil {
		return m.EgressConfig
	}
	return nil
}

func (m *Egress) GetDeliveryOrder() DeliveryOrder {
	if m != nil {
		return m.DeliveryOrder
	}
	return DeliveryOrder_UNORDERED
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Egress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Egress_ReplyUrl)(nil),
		(*Egress_ReplyToOriginalTopic)(nil),
	}
}

type Ingress struct {
	// Optional content mode to use when pushing messages to Kafka
	ContentMode ContentMode `protobuf:"varint,1,opt,name=contentMode,proto3,enum=ContentMode" json:"contentMode,omitempty"`
	// Ingress can both listen on a specific HTTP path
	// or listen to the / path but match the Host header
	//
	// Types that are valid to be assigned to IngressType:
	//	*Ingress_Path
	//	*Ingress_Host
	IngressType          isIngress_IngressType `protobuf_oneof:"ingressType"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Ingress) Reset()         { *m = Ingress{} }
func (m *Ingress) String() string { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()    {}
func (*Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{4}
}

func (m *Ingress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ingress.Unmarshal(m, b)
}
func (m *Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ingress.Marshal(b, m, deterministic)
}
func (m *Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingress.Merge(m, src)
}
func (m *Ingress) XXX_Size() int {
	return xxx_messageInfo_Ingress.Size(m)
}
func (m *Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Ingress proto.InternalMessageInfo

func (m *Ingress) GetContentMode() ContentMode {
	if m != nil {
		return m.ContentMode
	}
	return ContentMode_BINARY
}

type isIngress_IngressType interface {
	isIngress_IngressType()
}

type Ingress_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}

type Ingress_Host struct {
	Host string `protobuf:"bytes,3,opt,name=host,proto3,oneof"`
}

func (*Ingress_Path) isIngress_IngressType() {}

func (*Ingress_Host) isIngress_IngressType() {}

func (m *Ingress) GetIngressType() isIngress_IngressType {
	if m != nil {
		return m.IngressType
	}
	return nil
}

func (m *Ingress) GetPath() string {
	if x, ok := m.GetIngressType().(*Ingress_Path); ok {
		return x.Path
	}
	return ""
}

func (m *Ingress) GetHost() string {
	if x, ok := m.GetIngressType().(*Ingress_Host); ok {
		return x.Host
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Ingress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Ingress_Path)(nil),
		(*Ingress_Host)(nil),
	}
}

// Kubernetes resource reference.
type Reference struct {
	// Object id.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Object namespace.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Object name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Object version.
	Version              string   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Reference) Reset()         { *m = Reference{} }
func (m *Reference) String() string { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()    {}
func (*Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{5}
}

func (m *Reference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Reference.Unmarshal(m, b)
}
func (m *Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Reference.Marshal(b, m, deterministic)
}
func (m *Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reference.Merge(m, src)
}
func (m *Reference) XXX_Size() int {
	return xxx_messageInfo_Reference.Size(m)
}
func (m *Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_Reference proto.InternalMessageInfo

func (m *Reference) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Reference) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Reference) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Resource struct {
	// Id of the resource
	// It's the same as the Kubernetes resource uid
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Topics name
	// Note: If there is an ingress configured, then this field must have exactly 1 element otherwise,
	//  if the resource does just dispatch from Kafka, then this topic list can contain multiple elements
	Topics []string `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
	// A comma separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.
	// Note: we're using a comma separated list simply because that's how java kafka client likes it.
	BootstrapServers string `protobuf:"bytes,3,opt,name=bootstrapServers,proto3" json:"bootstrapServers,omitempty"`
	// Optional ingress for this topic
	Ingress *Ingress `protobuf:"bytes,4,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// Optional configuration of egress valid for the whole resource
	EgressConfig *EgressConfig `protobuf:"bytes,5,opt,name=egressConfig,proto3" json:"egressConfig,omitempty"`
	// Optional egresses for this topic
	Egresses []*Egress `protobuf:"bytes,6,rep,name=egresses,proto3" json:"egresses,omitempty"`
	// Types that are valid to be assigned to Auth:
	//	*Resource_AbsentAuth
	//	*Resource_AuthSecret
	Auth                 isResource_Auth `protobuf_oneof:"Auth"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{6}
}

func (m *Resource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resource.Unmarshal(m, b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return xxx_messageInfo_Resource.Size(m)
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Resource) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *Resource) GetBootstrapServers() string {
	if m != nil {
		return m.BootstrapServers
	}
	return ""
}

func (m *Resource) GetIngress() *Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Resource) GetEgressConfig() *EgressConfig {
	if m != nil {
		return m.EgressConfig
	}
	return nil
}

func (m *Resource) GetEgresses() []*Egress {
	if m != nil {
		return m.Egresses
	}
	return nil
}

type isResource_Auth interface {
	isResource_Auth()
}

type Resource_AbsentAuth struct {
	AbsentAuth *Empty `protobuf:"bytes,7,opt,name=absentAuth,proto3,oneof"`
}

type Resource_AuthSecret struct {
	AuthSecret *Reference `protobuf:"bytes,8,opt,name=authSecret,proto3,oneof"`
}

func (*Resource_AbsentAuth) isResource_Auth() {}

func (*Resource_AuthSecret) isResource_Auth() {}

func (m *Resource) GetAuth() isResource_Auth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func (m *Resource) GetAbsentAuth() *Empty {
	if x, ok := m.GetAuth().(*Resource_AbsentAuth); ok {
		return x.AbsentAuth
	}
	return nil
}

func (m *Resource) GetAuthSecret() *Reference {
	if x, ok := m.GetAuth().(*Resource_AuthSecret); ok {
		return x.AuthSecret
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Resource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Resource_AbsentAuth)(nil),
		(*Resource_AuthSecret)(nil),
	}
}

type Contract struct {
	// Count each contract update.
	// Make sure each data plane pod has the same contract generation number.
	Generation           uint64      `protobuf:"varint,1,opt,name=generation,proto3" json:"generation,omitempty"`
	Resources            []*Resource `protobuf:"bytes,2,rep,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_d19debeba7dea55a, []int{7}
}

func (m *Contract) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Contract.Unmarshal(m, b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return xxx_messageInfo_Contract.Size(m)
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetGeneration() uint64 {
	if m != nil {
		return m.Generation
	}
	return 0
}

func (m *Contract) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func init() {
	proto.RegisterEnum("BackoffPolicy", BackoffPolicy_name, BackoffPolicy_value)
	proto.RegisterEnum("DeliveryOrder", DeliveryOrder_name, DeliveryOrder_value)
	proto.RegisterEnum("ContentMode", ContentMode_name, ContentMode_value)
	proto.RegisterType((*Empty)(nil), "Empty")
	proto.RegisterType((*Filter)(nil), "Filter")
	proto.RegisterMapType((map[string]string)(nil), "Filter.AttributesEntry")
	proto.RegisterType((*EgressConfig)(nil), "EgressConfig")
	proto.RegisterType((*Egress)(nil), "Egress")
	proto.RegisterType((*Ingress)(nil), "Ingress")
	proto.RegisterType((*Reference)(nil), "Reference")
	proto.RegisterType((*Resource)(nil), "Resource")
	proto.RegisterType((*Contract)(nil), "Contract")
}

func init() { proto.RegisterFile("contract.proto", fileDescriptor_d19debeba7dea55a) }

var fileDescriptor_d19debeba7dea55a = []byte{
	// 804 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xc1, 0x8e, 0xe3, 0x44,
	0x10, 0x8d, 0x33, 0x19, 0x27, 0x29, 0x8f, 0x33, 0xa1, 0x35, 0x02, 0x6b, 0xb5, 0x82, 0xc8, 0x20,
	0x11, 0xc2, 0xe2, 0x15, 0x01, 0x09, 0x84, 0xe0, 0x30, 0x99, 0x04, 0x66, 0xa5, 0x65, 0x67, 0xd5,
	0xc9, 0x1c, 0x80, 0x53, 0xc7, 0xae, 0x24, 0x56, 0x3c, 0xdd, 0x56, 0xbb, 0x1d, 0xe1, 0x1b, 0x5f,
	0xc2, 0x97, 0xf0, 0x23, 0xfc, 0x0d, 0xea, 0xb6, 0x9d, 0x38, 0x2c, 0x12, 0xb7, 0xae, 0x57, 0xaf,
	0xab, 0xcb, 0xef, 0x95, 0x0b, 0x06, 0xa1, 0xe0, 0x4a, 0xb2, 0x50, 0x05, 0xa9, 0x14, 0x4a, 0xf8,
	0x5d, 0xb8, 0x5c, 0x3c, 0xa5, 0xaa, 0xf0, 0xff, 0xb0, 0xc0, 0xfe, 0x31, 0x4e, 0x14, 0x4a, 0xf2,
	0x0d, 0x00, 0x53, 0x4a, 0xc6, 0xeb, 0x5c, 0x61, 0xe6, 0x59, 0xa3, 0x8b, 0xb1, 0x33, 0xfd, 0x20,
	0x28, 0x93, 0xc1, 0xed, 0x31, 0xb3, 0xe0, 0x4a, 0x16, 0xb4, 0x41, 0x7d, 0xf6, 0x03, 0x5c, 0xff,
	0x2b, 0x4d, 0x86, 0x70, 0xb1, 0xc7, 0xc2, 0xb3, 0x46, 0xd6, 0xb8, 0x4f, 0xf5, 0x91, 0xdc, 0xc0,
	0xe5, 0x81, 0x25, 0x39, 0x7a, 0x6d, 0x83, 0x95, 0xc1, 0x77, 0xed, 0x6f, 0x2d, 0xff, 0x4f, 0x0b,
	0xae, 0x16, 0x5b, 0x89, 0x59, 0x76, 0x27, 0xf8, 0x26, 0xde, 0x92, 0x0f, 0x01, 0x22, 0x64, 0xd1,
	0x6b, 0x54, 0x0a, 0x65, 0x55, 0xa3, 0x81, 0xe8, 0x52, 0x12, 0x95, 0x2c, 0x4c, 0x29, 0x97, 0x96,
	0x01, 0xf9, 0x1a, 0xdc, 0x35, 0x0b, 0xf7, 0x62, 0xb3, 0x79, 0x2b, 0x92, 0x38, 0x2c, 0xbc, 0x8b,
	0x91, 0x35, 0x1e, 0x4c, 0x07, 0xc1, 0xac, 0x89, 0xd2, 0x73, 0x12, 0xf1, 0xe1, 0xaa, 0x02, 0xe6,
	0x98, 0xb0, 0xc2, 0xeb, 0x8c, 0xac, 0x71, 0x87, 0x9e, 0x61, 0xfe, 0xdf, 0x6d, 0xb0, 0xcb, 0x06,
	0xc9, 0x27, 0xe0, 0x86, 0x82, 0x67, 0xf9, 0x13, 0xca, 0x9f, 0xa4, 0xc8, 0xd3, 0xaa, 0xbb, 0x73,
	0x90, 0x8c, 0xc0, 0x89, 0x30, 0x53, 0x31, 0x67, 0x2a, 0x16, 0xbc, 0xfa, 0xe2, 0x26, 0x44, 0x9e,
	0x43, 0x4f, 0x62, 0x9a, 0x14, 0x8f, 0x32, 0x31, 0x7d, 0xf6, 0xef, 0x5b, 0xf4, 0x88, 0x90, 0xef,
	0xe1, 0xc6, 0x9c, 0x57, 0xe2, 0x41, 0xc6, 0xdb, 0x98, 0xb3, 0x64, 0x25, 0xd2, 0x38, 0x34, 0xcd,
	0x39, 0x53, 0x3b, 0x30, 0xd6, 0xdd, 0xb7, 0xe8, 0x7f, 0xb2, 0xc8, 0x47, 0x60, 0x6f, 0x8c, 0x69,
	0xde, 0xa5, 0xe1, 0x77, 0x2b, 0x0f, 0x69, 0x05, 0x6b, 0x73, 0xf2, 0x38, 0xf2, 0xec, 0xd2, 0x9c,
	0x3c, 0x8e, 0xc8, 0x97, 0x70, 0x85, 0x0d, 0x07, 0xbc, 0xae, 0xb9, 0xe8, 0x06, 0x4d, 0x5b, 0xe8,
	0x19, 0x45, 0xcb, 0x1d, 0x61, 0x12, 0x1f, 0x50, 0x16, 0x0f, 0x32, 0x42, 0xe9, 0xf5, 0x2a, 0xb9,
	0xe7, 0x4d, 0x94, 0x9e, 0x93, 0x66, 0xd7, 0xe0, 0x9a, 0x9e, 0x97, 0x4a, 0x32, 0x85, 0xdb, 0xc2,
	0x57, 0xd0, 0x7d, 0xc5, 0x4b, 0x6d, 0x03, 0x70, 0xf4, 0x94, 0x22, 0x57, 0x3f, 0x8b, 0x08, 0x8d,
	0xb2, 0x83, 0xe9, 0x55, 0x70, 0x77, 0xc2, 0x68, 0x93, 0x40, 0x6e, 0xa0, 0x93, 0x32, 0xb5, 0x2b,
	0xe5, 0xbd, 0x6f, 0x51, 0x13, 0x69, 0x74, 0x27, 0x32, 0x75, 0x54, 0xd5, 0x44, 0x33, 0x17, 0x9c,
	0xb8, 0x7c, 0x66, 0x55, 0xa4, 0xe8, 0xef, 0xa1, 0x4f, 0x71, 0x83, 0x12, 0x79, 0x88, 0x84, 0x40,
	0x27, 0xd7, 0x7a, 0x94, 0x56, 0x9a, 0x33, 0x79, 0x0e, 0x7d, 0xce, 0x9e, 0x30, 0x4b, 0x59, 0x58,
	0x4f, 0xec, 0x09, 0xd0, 0x37, 0x74, 0x50, 0xbe, 0x41, 0xcd, 0x99, 0x78, 0xd0, 0x3d, 0xa0, 0xcc,
	0xb4, 0xdf, 0x1d, 0x03, 0xd7, 0xa1, 0xff, 0x57, 0x1b, 0x7a, 0x14, 0x33, 0x91, 0xcb, 0x10, 0x6b,
	0xed, 0xad, 0x93, 0xf6, 0xef, 0x83, 0xad, 0xb4, 0x6f, 0x99, 0xd7, 0x1e, 0x5d, 0x8c, 0xfb, 0xb4,
	0x8a, 0xc8, 0x04, 0x86, 0x6b, 0x21, 0x54, 0xa6, 0x24, 0x4b, 0x97, 0x28, 0x75, 0xb5, 0xea, 0xc1,
	0x77, 0x70, 0xe2, 0x43, 0xb7, 0xfa, 0xbc, 0x6a, 0x46, 0x7a, 0x41, 0xa5, 0x2a, 0xad, 0x13, 0xef,
	0x78, 0x7c, 0xf9, 0xff, 0x1e, 0x7f, 0x0c, 0xbd, 0x32, 0xc6, 0xcc, 0xb3, 0xcd, 0x3e, 0xe8, 0x56,
	0x74, 0x7a, 0x4c, 0x90, 0x31, 0x00, 0x5b, 0x67, 0xc8, 0xd5, 0x6d, 0xae, 0x76, 0xd5, 0xe4, 0x9c,
	0x46, 0xb4, 0x91, 0x23, 0x2f, 0x00, 0x58, 0xae, 0x76, 0x4b, 0x0c, 0x25, 0x2a, 0x33, 0x2f, 0xce,
	0x14, 0x82, 0xa3, 0x11, 0x86, 0x7d, 0xcc, 0xcf, 0x6c, 0xe8, 0xe8, 0x5b, 0xfe, 0x12, 0x7a, 0x77,
	0xd5, 0xf2, 0xd2, 0x9b, 0x61, 0x8b, 0x1c, 0x65, 0xf9, 0x5f, 0x59, 0xe6, 0x5f, 0x6d, 0x20, 0xe4,
	0x53, 0xe8, 0xcb, 0x4a, 0xe9, 0x52, 0x4e, 0x67, 0xda, 0x0f, 0x6a, 0xed, 0xe9, 0x29, 0x37, 0x79,
	0x01, 0xee, 0xd9, 0x5a, 0x20, 0xd7, 0xe0, 0x2c, 0x7e, 0x4f, 0x05, 0x47, 0xae, 0x62, 0x96, 0x0c,
	0x5b, 0x04, 0xc0, 0x7e, 0x1d, 0x73, 0x64, 0x72, 0x68, 0x4d, 0x3e, 0x07, 0xf7, 0x6c, 0xaa, 0x89,
	0x0b, 0xfd, 0xc7, 0x37, 0x0f, 0x74, 0xbe, 0xa0, 0x8b, 0xf9, 0xb0, 0x45, 0x1c, 0xe8, 0xd6, 0x81,
	0x35, 0xf9, 0x0c, 0x9c, 0xc6, 0xc8, 0xea, 0x3a, 0xb3, 0x57, 0x6f, 0x6e, 0xe9, 0x2f, 0xc3, 0x16,
	0x19, 0x00, 0x2c, 0x57, 0xf4, 0xf1, 0x6e, 0xf5, 0x68, 0xa8, 0xb3, 0xdf, 0x60, 0x12, 0xe1, 0x21,
	0xd8, 0xeb, 0xa5, 0x70, 0xc0, 0x00, 0x0f, 0xfa, 0x75, 0xbe, 0x0d, 0xf6, 0x6c, 0xb3, 0x67, 0xc1,
	0x5a, 0x8a, 0x3d, 0xca, 0xa0, 0xde, 0xdc, 0xb3, 0xf7, 0xe6, 0x4c, 0xb1, 0xb7, 0x09, 0xe3, 0x58,
	0xeb, 0xf1, 0xeb, 0x33, 0x93, 0x14, 0xc9, 0x17, 0xa9, 0x86, 0x5f, 0xa6, 0xfb, 0xed, 0xcb, 0x9a,
	0xbe, 0xb6, 0xcd, 0xa6, 0xff, 0xea, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7d, 0xab, 0xd2, 0xe3,
	0xfb, 0x05, 0x00, 0x00,
}
