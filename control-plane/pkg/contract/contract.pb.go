// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/def/contract.proto

package contract

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// CloudEvent content mode
type ContentMode int32

const (
	ContentMode_BINARY     ContentMode = 0
	ContentMode_STRUCTURED ContentMode = 1
)

var ContentMode_name = map[int32]string{
	0: "BINARY",
	1: "STRUCTURED",
}

var ContentMode_value = map[string]int32{
	"BINARY":     0,
	"STRUCTURED": 1,
}

func (x ContentMode) String() string {
	return proto.EnumName(ContentMode_name, int32(x))
}

func (ContentMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{0}
}

type Filter struct {
	// attributes filters events by exact match on event context attributes.
	// Each key in the map is compared with the equivalent key in the event
	// context. An event passes the filter if all values are equal to the
	// specified values.
	//
	// Nested context attributes are not supported as keys. Only string values are supported.
	Attributes           map[string]string `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{0}
}

func (m *Filter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Filter.Unmarshal(m, b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return xxx_messageInfo_Filter.Size(m)
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type Egress struct {
	// consumer group name
	ConsumerGroup string `protobuf:"bytes,1,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	// destination is the sink where events are sent.
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to ReplyStrategy:
	//	*Egress_ReplyUrl
	//	*Egress_ReplyToOriginalTopic
	ReplyStrategy isEgress_ReplyStrategy `protobuf_oneof:"replyStrategy"`
	// Dead letter is where the event is sent when something goes wrong
	DeadLetter           string   `protobuf:"bytes,5,opt,name=deadLetter,proto3" json:"deadLetter,omitempty"`
	Filter               *Filter  `protobuf:"bytes,6,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Egress) Reset()         { *m = Egress{} }
func (m *Egress) String() string { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()    {}
func (*Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{1}
}

func (m *Egress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Egress.Unmarshal(m, b)
}
func (m *Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Egress.Marshal(b, m, deterministic)
}
func (m *Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Egress.Merge(m, src)
}
func (m *Egress) XXX_Size() int {
	return xxx_messageInfo_Egress.Size(m)
}
func (m *Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Egress proto.InternalMessageInfo

func (m *Egress) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *Egress) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type isEgress_ReplyStrategy interface {
	isEgress_ReplyStrategy()
}

type Egress_ReplyUrl struct {
	ReplyUrl string `protobuf:"bytes,3,opt,name=replyUrl,proto3,oneof"`
}

type Egress_ReplyToOriginalTopic struct {
	ReplyToOriginalTopic *empty.Empty `protobuf:"bytes,4,opt,name=replyToOriginalTopic,proto3,oneof"`
}

func (*Egress_ReplyUrl) isEgress_ReplyStrategy() {}

func (*Egress_ReplyToOriginalTopic) isEgress_ReplyStrategy() {}

func (m *Egress) GetReplyStrategy() isEgress_ReplyStrategy {
	if m != nil {
		return m.ReplyStrategy
	}
	return nil
}

func (m *Egress) GetReplyUrl() string {
	if x, ok := m.GetReplyStrategy().(*Egress_ReplyUrl); ok {
		return x.ReplyUrl
	}
	return ""
}

func (m *Egress) GetReplyToOriginalTopic() *empty.Empty {
	if x, ok := m.GetReplyStrategy().(*Egress_ReplyToOriginalTopic); ok {
		return x.ReplyToOriginalTopic
	}
	return nil
}

func (m *Egress) GetDeadLetter() string {
	if m != nil {
		return m.DeadLetter
	}
	return ""
}

func (m *Egress) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Egress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Egress_ReplyUrl)(nil),
		(*Egress_ReplyToOriginalTopic)(nil),
	}
}

type Ingress struct {
	// Optional content mode to use when pushing messages to Kafka
	ContentMode ContentMode `protobuf:"varint,1,opt,name=contentMode,proto3,enum=ContentMode" json:"contentMode,omitempty"`
	// Ingress can both listen on a specific HTTP path
	// or listen to the / path but match the Host header
	//
	// Types that are valid to be assigned to IngressType:
	//	*Ingress_Path
	//	*Ingress_Host
	IngressType          isIngress_IngressType `protobuf_oneof:"ingressType"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Ingress) Reset()         { *m = Ingress{} }
func (m *Ingress) String() string { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()    {}
func (*Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{2}
}

func (m *Ingress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ingress.Unmarshal(m, b)
}
func (m *Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ingress.Marshal(b, m, deterministic)
}
func (m *Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ingress.Merge(m, src)
}
func (m *Ingress) XXX_Size() int {
	return xxx_messageInfo_Ingress.Size(m)
}
func (m *Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Ingress proto.InternalMessageInfo

func (m *Ingress) GetContentMode() ContentMode {
	if m != nil {
		return m.ContentMode
	}
	return ContentMode_BINARY
}

type isIngress_IngressType interface {
	isIngress_IngressType()
}

type Ingress_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}

type Ingress_Host struct {
	Host string `protobuf:"bytes,3,opt,name=host,proto3,oneof"`
}

func (*Ingress_Path) isIngress_IngressType() {}

func (*Ingress_Host) isIngress_IngressType() {}

func (m *Ingress) GetIngressType() isIngress_IngressType {
	if m != nil {
		return m.IngressType
	}
	return nil
}

func (m *Ingress) GetPath() string {
	if x, ok := m.GetIngressType().(*Ingress_Path); ok {
		return x.Path
	}
	return ""
}

func (m *Ingress) GetHost() string {
	if x, ok := m.GetIngressType().(*Ingress_Host); ok {
		return x.Host
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Ingress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Ingress_Path)(nil),
		(*Ingress_Host)(nil),
	}
}

type Resource struct {
	// Id of the resource
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Topics name
	// Note: If there is an ingress configured, then this field must have exactly 1 element otherwise,
	//  if the resource does just dispatch from Kafka, then this topic list can contain multiple elements
	Topics []string `protobuf:"bytes,2,rep,name=topics,proto3" json:"topics,omitempty"`
	// A comma separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.
	// Note: we're using a comma separated list simply because that's how java kafka client likes it.
	BootstrapServers string `protobuf:"bytes,3,opt,name=bootstrapServers,proto3" json:"bootstrapServers,omitempty"`
	// Optional ingress for this topic
	Ingress *Ingress `protobuf:"bytes,4,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// Optional egresses for this topic
	Egresses             []*Egress `protobuf:"bytes,5,rep,name=egresses,proto3" json:"egresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{3}
}

func (m *Resource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resource.Unmarshal(m, b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return xxx_messageInfo_Resource.Size(m)
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Resource) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *Resource) GetBootstrapServers() string {
	if m != nil {
		return m.BootstrapServers
	}
	return ""
}

func (m *Resource) GetIngress() *Ingress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Resource) GetEgresses() []*Egress {
	if m != nil {
		return m.Egresses
	}
	return nil
}

type Contract struct {
	// Count each contract update.
	// Make sure each data plane pod has the same contract generation number.
	Generation           uint64      `protobuf:"varint,1,opt,name=generation,proto3" json:"generation,omitempty"`
	Resources            []*Resource `protobuf:"bytes,2,rep,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_48a96a16a5e7b878, []int{4}
}

func (m *Contract) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Contract.Unmarshal(m, b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return xxx_messageInfo_Contract.Size(m)
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetGeneration() uint64 {
	if m != nil {
		return m.Generation
	}
	return 0
}

func (m *Contract) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func init() {
	proto.RegisterEnum("ContentMode", ContentMode_name, ContentMode_value)
	proto.RegisterType((*Filter)(nil), "Filter")
	proto.RegisterMapType((map[string]string)(nil), "Filter.AttributesEntry")
	proto.RegisterType((*Egress)(nil), "Egress")
	proto.RegisterType((*Ingress)(nil), "Ingress")
	proto.RegisterType((*Resource)(nil), "Resource")
	proto.RegisterType((*Contract)(nil), "Contract")
}

func init() { proto.RegisterFile("proto/def/contract.proto", fileDescriptor_48a96a16a5e7b878) }

var fileDescriptor_48a96a16a5e7b878 = []byte{
	// 577 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0xe3, 0xa4, 0x75, 0x92, 0x31, 0x6d, 0xc3, 0xaa, 0x2a, 0x56, 0x41, 0x10, 0x05, 0x24,
	0x42, 0x25, 0x36, 0x52, 0x38, 0x80, 0x90, 0x38, 0x34, 0x6d, 0xa0, 0x95, 0xca, 0x87, 0x36, 0xe9,
	0x01, 0x38, 0x6d, 0xe2, 0x89, 0x6b, 0xc5, 0xdd, 0xb5, 0xd6, 0x93, 0x48, 0xbe, 0xf1, 0x04, 0xbc,
	0x06, 0xaf, 0x89, 0xbc, 0x76, 0x52, 0xf3, 0x71, 0xdb, 0xf9, 0xff, 0xd7, 0xf3, 0xf1, 0xf3, 0x2c,
	0xf8, 0x89, 0xd1, 0xa4, 0x07, 0x01, 0x2e, 0x06, 0x73, 0xad, 0xc8, 0xc8, 0x39, 0x71, 0x2b, 0x1d,
	0x3f, 0x0c, 0xb5, 0x0e, 0x63, 0x1c, 0xd8, 0x68, 0xb6, 0x5a, 0x0c, 0xf0, 0x36, 0xa1, 0xac, 0x30,
	0x7b, 0x3f, 0x1c, 0x70, 0xdf, 0x47, 0x31, 0xa1, 0x61, 0xaf, 0x01, 0x24, 0x91, 0x89, 0x66, 0x2b,
	0xc2, 0xd4, 0x77, 0xba, 0x8d, 0xbe, 0x37, 0x7c, 0xc0, 0x0b, 0x93, 0x9f, 0x6e, 0x9d, 0xb1, 0x22,
	0x93, 0x89, 0xca, 0xd5, 0xe3, 0x77, 0x70, 0xf0, 0x97, 0xcd, 0x3a, 0xd0, 0x58, 0x62, 0xe6, 0x3b,
	0x5d, 0xa7, 0xdf, 0x16, 0xf9, 0x91, 0x1d, 0xc2, 0xee, 0x5a, 0xc6, 0x2b, 0xf4, 0xeb, 0x56, 0x2b,
	0x82, 0xb7, 0xf5, 0x37, 0x4e, 0xef, 0x67, 0x1d, 0xdc, 0x71, 0x68, 0x30, 0x4d, 0xd9, 0x33, 0xd8,
	0x9b, 0x6b, 0x95, 0xae, 0x6e, 0xd1, 0x7c, 0x30, 0x7a, 0x95, 0x94, 0x09, 0xfe, 0x14, 0x59, 0x17,
	0xbc, 0x00, 0x53, 0x8a, 0x94, 0xa4, 0x48, 0xab, 0x32, 0x61, 0x55, 0x62, 0x8f, 0xa0, 0x65, 0x30,
	0x89, 0xb3, 0x6b, 0x13, 0xfb, 0x8d, 0xdc, 0xbe, 0xa8, 0x89, 0xad, 0xc2, 0xae, 0xe0, 0xd0, 0x9e,
	0xa7, 0xfa, 0xb3, 0x89, 0xc2, 0x48, 0xc9, 0x78, 0xaa, 0x93, 0x68, 0xee, 0xef, 0x74, 0x9d, 0xbe,
	0x37, 0x3c, 0xe2, 0x05, 0x2f, 0xbe, 0xe1, 0xc5, 0xc7, 0x39, 0xaf, 0x8b, 0x9a, 0xf8, 0xef, 0x57,
	0xec, 0x31, 0x40, 0x80, 0x32, 0xb8, 0x42, 0x22, 0x34, 0xfe, 0xae, 0x6d, 0xa6, 0xa2, 0xb0, 0x27,
	0xe0, 0x2e, 0x2c, 0x43, 0xdf, 0xb5, 0xf9, 0x9b, 0x25, 0x52, 0x51, 0xca, 0xa3, 0x03, 0xd8, 0xb3,
	0x89, 0x27, 0x64, 0x24, 0x61, 0x98, 0xf5, 0x08, 0x9a, 0x97, 0xaa, 0x00, 0xc2, 0xc1, 0xcb, 0xff,
	0x26, 0x2a, 0xfa, 0xa8, 0x03, 0xb4, 0x38, 0xf6, 0x87, 0xf7, 0xf8, 0xd9, 0x9d, 0x26, 0xaa, 0x17,
	0xd8, 0x21, 0xec, 0x24, 0x92, 0x6e, 0x0a, 0x26, 0x17, 0x35, 0x61, 0xa3, 0x5c, 0xbd, 0xd1, 0x29,
	0x6d, 0x51, 0xd8, 0x68, 0xb4, 0x07, 0x5e, 0x54, 0x94, 0x99, 0x66, 0x09, 0xf6, 0x7e, 0x39, 0xd0,
	0x12, 0x98, 0xea, 0x95, 0x99, 0x23, 0xdb, 0x87, 0x7a, 0x14, 0x94, 0xf4, 0xeb, 0x51, 0xc0, 0x8e,
	0xc0, 0xa5, 0x7c, 0xda, 0xd4, 0xaf, 0x77, 0x1b, 0xfd, 0xb6, 0x28, 0x23, 0x76, 0x02, 0x9d, 0x99,
	0xd6, 0x94, 0x92, 0x91, 0xc9, 0x04, 0xcd, 0x1a, 0x4d, 0x5a, 0x54, 0x11, 0xff, 0xe8, 0xac, 0x07,
	0xcd, 0xb2, 0x5e, 0x49, 0xba, 0xc5, 0xcb, 0x31, 0xc5, 0xc6, 0x60, 0x4f, 0xa1, 0x85, 0xf6, 0x84,
	0xa9, 0xbf, 0x6b, 0x37, 0xb0, 0xc9, 0x8b, 0xdd, 0x10, 0x5b, 0xa3, 0x37, 0x81, 0xd6, 0x59, 0xb9,
	0xe2, 0x39, 0xfd, 0x10, 0x15, 0x9a, 0x62, 0x15, 0xf2, 0x86, 0x77, 0x44, 0x45, 0x61, 0xcf, 0xa1,
	0x6d, 0xca, 0xa1, 0x8a, 0xde, 0xbd, 0x61, 0x9b, 0x6f, 0xc6, 0x14, 0x77, 0xde, 0xc9, 0x0b, 0xf0,
	0x2a, 0x54, 0x19, 0x80, 0x3b, 0xba, 0xfc, 0x74, 0x2a, 0xbe, 0x76, 0x6a, 0x6c, 0x1f, 0x60, 0x32,
	0x15, 0xd7, 0x67, 0xd3, 0x6b, 0x31, 0x3e, 0xef, 0x38, 0xa3, 0xef, 0x70, 0x12, 0xe0, 0x9a, 0x2f,
	0xf3, 0x65, 0x5b, 0x23, 0xc7, 0x35, 0x2a, 0x8a, 0x54, 0xc8, 0x97, 0x72, 0xb1, 0x94, 0x7c, 0x66,
	0xf4, 0x12, 0x0d, 0xdf, 0x3c, 0xc2, 0xd1, 0xfd, 0x73, 0x49, 0xf2, 0x4b, 0x2c, 0x15, 0x6e, 0x9a,
	0xfe, 0x76, 0x6c, 0x4d, 0x1d, 0xbf, 0x4c, 0x72, 0x79, 0x90, 0x2c, 0xc3, 0xed, 0x9b, 0x9d, 0xb9,
	0x76, 0xed, 0x5e, 0xfd, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xdd, 0xa9, 0x23, 0xed, 0xd0, 0x03, 0x00,
	0x00,
}
